
##############################################################################
#                                                                            #
# Early setup - necessary packages etc                                       #
#                                                                            #
##############################################################################

import os
import pandas as pd
import openpyxl as pyxl
import datetime
import sys

##############################################################################
#                                                                            #
# Preparation                                                                #
#   creating objects                                                         #
#   loading settings file                                                    #
#   specifying paths, working directories etc                                #
#                                                                            #
##############################################################################

# script can be initialized by typing:
# python H:\EXAMPLE\EXAMPLE\EXAMPLE script.py
# in anaconda prompt; make sure that folder in that line contains also
# settings and all exported queries

# setting working directory to the location of .py script file
os.chdir(os.path.dirname(sys.argv[0]))
Path = os.getcwd()
    
Setup = pd.read_excel('Settings.xlsm')
SurveyFullName = Setup.iloc[9,2]
Output = Setup.iloc[11,2]
TemplateName = Setup.iloc[12,2]
SubmissionDeadline = Setup.iloc[13,2].date()
InternalDeadline = Setup.iloc[14,2].date()
QAD = Setup.iloc[15,2].date()
ExcEntities_YN = Setup.iloc[19,2]
ExcIncumbents_YN = Setup.iloc[20,2]
AGCRematches_YN = Setup.iloc[21,2]
MultipleYTPos_YN = Setup.iloc[22,2]
MultipleYTAll_YN = Setup.iloc[23,2]
Deadlines_YN = Setup.iloc[24,2]
QAD_YN = Setup.iloc[25,2]

FileNames = Setup.iloc[28:35,2].tolist()
ReportName = 'Problematic Companies {} - report.xlsx'.format(SurveyFullName)
TemplatePath = os.path.join(Path,TemplateName)

Summary = []
ExcEntitiesData = []
ExcReasonData = []
ExcIncumbentsData = []
AGCRematchesData = []
MultipleYTPositionsData = []
MultipleYTPositionsAll = []
AfterDeadlinesData = []
MDAData = []

tresholds = Setup.iloc[0:8,20:23]


# function responsible for loading data from exported GST queries
def import_xlsx_files(Path):

    print('getting data from excel files...')
    
    global Summary
    Summary = pd.read_excel(os.path.join(Path, FileNames[0]))

    global ExcEntitiesData
    if ExcEntities_YN == 'Y' and pd.notna(FileNames[1]):
        ExcEntitiesData = pd.read_excel(os.path.join(Path, FileNames[1]))

    global ExcReasonData   
    if ExcEntities_YN == 'Y' and pd.notna(FileNames[2]):
        ExcReasonData = pd.read_excel(os.path.join(Path, FileNames[2]))

    global ExcIncumbentsData    
    if ExcIncumbents_YN == 'Y' and pd.notna(FileNames[3]):
        ExcIncumbentsData = pd.read_excel(os.path.join(Path, FileNames[3]))

    global AGCRematchesData     
    if AGCRematches_YN == 'Y' and pd.notna(FileNames[4]):
        AGCRematchesData = pd.read_excel(os.path.join(Path, FileNames[4]))

    global MultipleYTPositionsData    
    if MultipleYTPos_YN == 'Y' and pd.notna(FileNames[5]):
        MultipleYTPositionsData = pd.read_excel(os.path.join(Path, FileNames[5]))

    global MultipleYTPositionsAll        
    if MultipleYTAll_YN == 'Y' and pd.notna(FileNames[6]):
        MultipleYTPositionsAll = pd.read_excel(os.path.join(Path, FileNames[6]))

    print('done!')


##############################################################################
#                                                                            #
# Main body                                                                  #
#   data transformations                                                     #
#   final XLSX file creations                                                #
#                                                                            #
##############################################################################

# making sure columns are named correctly - e.g for surveys that are using
# CPY_CODE instead of CO_CODE2 etc etc etc
def make_names_standard():

    global Summary
    SummaryColumns = Setup.iloc[0:12]['SummaryColumns']
    Summary.columns = SummaryColumns.dropna()

    if ExcEntities_YN == 'Y':
        global ExcEntitiesData
        ExcEntitiesColumns = Setup.iloc[0:6]['ExcEntitiesColumns']
        ExcEntitiesData.columns = ExcEntitiesColumns.dropna()

        global ExcReasonData
        ExcEntitiesReasonColumns = Setup.iloc[0:7]['ExcEntitiesReasonColumns']
        ExcReasonData.columns = ExcEntitiesReasonColumns.dropna()

    if ExcIncumbents_YN == 'Y':
        global ExcIncumbentsData
        ExcIncumbentsColumns = Setup.iloc[0:38]['ExcIncumbentsColumns']
        ExcIncumbentsData.columns = ExcIncumbentsColumns.dropna()

    if AGCRematches_YN == 'Y':
        global AGCRematchesData
        AGCRematchesColumns = Setup.iloc[0:5]['AGCRematchesColumns']
        AGCRematchesData.columns = AGCRematchesColumns.dropna()

    if MultipleYTPos_YN == 'Y':
        global MultipleYTPositionsData
        MultipleYTPosColumns = Setup.iloc[0:8]['MultipleYTPosColumns']
        MultipleYTPositionsData.columns = MultipleYTPosColumns.dropna()

    if MultipleYTAll_YN == 'Y':
        global MultipleYTPositionsAll
        MultipleYTAllColumns = Setup.iloc[0:8]['MultipleYTAllColumns']
        MultipleYTPositionsAll.columns = MultipleYTAllColumns.dropna()


#   Excluded Entities sheet - adding perc of excluded entities
#   and filtering out records below the treshold:
def create_excluded_entities():
    if ExcEntities_YN == 'Y':
        global ExcEntitiesData
        
        ExcEntitiesData = ExcEntitiesData[ExcEntitiesData.SUBMITTED 
                                          >= tresholds.iloc[1,2]]

        ExcEntitiesData.loc[:,'EXCLUDED_PERC'] = round(
            ExcEntitiesData['EXCLUDED'] / 
            ExcEntitiesData['SUBMITTED'], 2)
        
        ExcEntitiesData = ExcEntitiesData[ExcEntitiesData.EXCLUDED_PERC 
                                          >= tresholds.iloc[0,2]]


# preparing clean Exclude reasons
# matching them with Excluded Entities 
def create_exclude_reasons():
    if ExcEntities_YN == 'Y':
        
        global ExcReasonData
        ExcReasonData['EXCLUDE_REASON'] = ExcReasonData['EXCLUDE_REASON'].fillna(value = 'Unspecified exclude reason')
        ExcReasonData['CO_NAME2'] = ExcReasonData['CO_NAME2'].fillna(value = 'Unnamed Entity')    
        ExcReasonData['EXCLUDE_REASON'] = ExcReasonData['CO_NAME2']+": "+ExcReasonData['EXCLUDE_REASON']

        global ExcEntitiesData
        for x in ExcReasonData['SUBMISSIONID'].unique():
            data = ExcReasonData.loc[ExcReasonData['SUBMISSIONID'] == x]
            sep = (';'+'\n')
            z = sep.join(data['EXCLUDE_REASON'])
            ExcEntitiesData.loc[ExcEntitiesData['CONTACT_SUBMISSIONID'] == x, 
                                     'EXCLUDE_REASON'] = z
            ExcEntitiesData['EXCLUDE_REASON'].fillna(value = '',inplace = True)

        # removing Reasons dataframe to clean up some memory
        del ExcReasonData


# calculating Excluded Incumbents data, applying tresholds to data
def create_excluded_incumbents():
    if ExcIncumbents_YN == 'Y':
        global ExcIncumbentsData

        ExcIncumbentsData.loc[:,'EXCLUDED_PERC'] = round(
                ExcIncumbentsData['EXCLUDED_INCUMBENTS'] /
                ExcIncumbentsData['ALLINCUMBENTS'], 2)
        
        # checking treshold for duplicates requires creating temporary column
        # for calculations
        y = 0
        for x in ExcIncumbentsData.EF_2_COUNT:
            if x > 0:
                ExcIncumbentsData.loc[y,"dupl_perc"] = (ExcIncumbentsData.iloc[y,12] 
                /sum(ExcIncumbentsData.iloc[y,9:38]))
            else:
                ExcIncumbentsData.loc[y,"dupl_perc"] = 0
            y = y + 1
        
        ExcIncumbentsData = ExcIncumbentsData[ExcIncumbentsData.ALLINCUMBENTS 
                                              >= tresholds.iloc[3,2]]
        ExcIncumbentsData = ExcIncumbentsData[ExcIncumbentsData.EXCLUDED_PERC 
                                              >= tresholds.iloc[2,2]]
        ExcIncumbentsData = ExcIncumbentsData[ExcIncumbentsData.dupl_perc 
                                              <= tresholds.iloc[4,2]]
        ExcIncumbentsData = ExcIncumbentsData.drop(columns = 'dupl_perc')


# YTPositions and YTAllData require only treshold application
def create_YTPos():
    if MultipleYTPos_YN == 'Y':
        global MultipleYTPositionsData
        MultipleYTPositionsData = MultipleYTPositionsData[MultipleYTPositionsData.UNIQUEYOURTITLE 
                                                          >= tresholds.iloc[5,2]]


def create_YTAll():        
    if MultipleYTAll_YN == 'Y':
        global MultipleYTPositionsAll
        # creating temporary object to apply treshold 
        Titles = MultipleYTPositionsAll.YOUR_TITLE.value_counts().to_frame()
        Titles = Titles.YOUR_TITLE[Titles.YOUR_TITLE >= tresholds.iloc[6,2]].to_frame()   
        Titles['YOUR_TITLE'] = Titles.index

        # filtering final DF whit Titles that are fullfiling treshold criteria 
        MultipleYTPositionsAll = MultipleYTPositionsAll[MultipleYTPositionsAll['YOUR_TITLE'].isin(Titles['YOUR_TITLE'])]


# Creating Data for 'Deadlines' tab - downloading CONTACT info and calculating
# degree and type of delays
# As a first step we need to have function for date conversion
# (GST exports store date in excel-like format)
def date_convert(gst_date):
    return(datetime.datetime(1899, 12, 30) + datetime.timedelta(days = gst_date))        
# Then we can use it in creating After Deadline Tab       
def create_after_deadline():
    if Deadlines_YN == 'Y':
        global AfterDeadlinesData
        AfterDeadlinesData = Summary.loc[:,['SUBMISSIONID', 'CO_CODE1',
                                          'CONTACTNAME','CO_NAME1','CN_TITLE',
                                          'CN_PHONE','CONTACTEMAIL',
                                          'IMPORTDATE',]]
    # converting submission date into more readable format
    for x in AfterDeadlinesData['IMPORTDATE']:
        AfterDeadlinesData.loc[AfterDeadlinesData['IMPORTDATE'] == x,
                               'IMPORTDATE'] = date_convert(x).date()
    
    # calculating if submission breached either of 2 deadlines
    AfterDeadlinesData['checkCLIENT'] = AfterDeadlinesData['IMPORTDATE'] - SubmissionDeadline
    AfterDeadlinesData['checkCLIENT'] = AfterDeadlinesData['checkCLIENT'].dt.days
    
    AfterDeadlinesData['checkINT'] = AfterDeadlinesData['IMPORTDATE'] - InternalDeadline
    AfterDeadlinesData['checkINT'] = AfterDeadlinesData['checkINT'].dt.days
    
    # creating columns in which we will store data about the type of delay
    AfterDeadlinesData['DEADLINE_BREACH'] = ''
    AfterDeadlinesData['DELAY'] = ''
    
    # creating loop which will determine what type of delay should be 
    # picked for each sub
    y = 0
    for x in AfterDeadlinesData['SUBMISSIONID']:
        client = AfterDeadlinesData.iloc[y,8]
        internal = AfterDeadlinesData.iloc[y,9]
        if internal > 0:
            AfterDeadlinesData.iloc[y,10] = 'Internal'
            AfterDeadlinesData.iloc[y,11] = internal
        elif client > 0:
                AfterDeadlinesData.iloc[y,10] = 'Client'
                AfterDeadlinesData.iloc[y,11] = client
        else:
            AfterDeadlinesData.iloc[y,10] = "REMOVE ROW"
        y = y + 1

    # removing temporary technical columns, filtering out correct records,
    # setting data in correct order
    AfterDeadlinesData = AfterDeadlinesData.drop(columns = ['checkINT',
                                                            'checkCLIENT'])
    AfterDeadlinesData = (
            AfterDeadlinesData[AfterDeadlinesData.DEADLINE_BREACH != "REMOVE ROW"])
    ColumnOrder = Setup.iloc[0:10]['AfterDeadlineOrder'].tolist()
    AfterDeadlinesData = AfterDeadlinesData[ColumnOrder]        


# Creating data for 'DVF after QAD' tab
def create_mda():
    if QAD_YN == 'Y':
        global MDAData
        MDAData = Summary.loc[:,['SUBMISSIONID', 'CO_CODE1', 'MERCER_ACTION',
                                          'CONTACTNAME','CO_NAME1','CN_TITLE',
                                          'CN_PHONE','CONTACTEMAIL',
                                          'RETURNED_SAW',]]
        
        # Removing rows with no date (some records in MBD had those)
        MDAData = MDAData[~MDAData['RETURNED_SAW'].isnull()]

        # converting DVF date into more readable format
        for x in MDAData['RETURNED_SAW']:
            MDAData.loc[MDAData['RETURNED_SAW'] == x,
                        'RETURNED_SAW'] = date_convert(x).date()
        
        # calculating if DVF broke deadline
        MDAData['DELAY'] = MDAData['RETURNED_SAW'] - QAD
        MDAData['DELAY'] = MDAData['DELAY'].dt.days
        
        # preparing QAD Y/N column
        MDAData['QAD_BREACH'] = ''
        y = 0
        for x in MDAData['SUBMISSIONID']:
            qad_check = MDAData.iloc[y,9]
            if qad_check > int(tresholds.iloc[7,2]):   #cutoff as per Treshold
                MDAData.iloc[y,10] = "Y"
            else:
                MDAData.iloc[y,10] = "N"
            y = y + 1
            
        # Preparing MDA Y/N column
        MDAData['MERCER_ACTION'] = MDAData['MERCER_ACTION'].replace(1,'Y')
        MDAData['MERCER_ACTION'].fillna(value = 'N', inplace = True)

        # filtering out records which are neither afterQAD / MDA,
        # sorting, removing technical columns etc
        MDAData['remove_col'] = MDAData['MERCER_ACTION'] + MDAData['QAD_BREACH']
        MDAData = MDAData[MDAData.remove_col != "NN"]
        MDAData = MDAData.drop(columns = 'remove_col')
        ColumnOrder = Setup.iloc[0:11]['MDAOrder'].tolist()
        MDAData = MDAData[ColumnOrder]


# INSERTING CONTACT DATA
# Function that'll identify which sheets need to be updated with Contact data
# then paste it and rearrange columns in correct order
def create_contact_details():    
    ContactSlice = Summary.loc[:,['SUBMISSIONID', 'CONTACTNAME',
                           'CN_TITLE','CN_PHONE','CONTACTEMAIL']]
    
    if ExcEntities_YN == 'Y':
        global ExcEntitiesData
        ExcEntitiesData = ExcEntitiesData.merge(ContactSlice, 
                                        left_on='CONTACT_SUBMISSIONID',
                                        right_on='SUBMISSIONID')
        ExcEntitiesData = ExcEntitiesData.drop(columns='SUBMISSIONID')
        ColumnOrder = Setup.iloc[0:12]['ExcEntitiesOrder'].tolist()
        ExcEntitiesData = ExcEntitiesData[ColumnOrder]

    if ExcIncumbents_YN == 'Y':
        global ExcIncumbentsData
        ExcIncumbentsData = ExcIncumbentsData.merge(ContactSlice,
                                                    left_on='ORGDATA_SUBMISSIONID',
                                                    right_on='SUBMISSIONID')
        ExcIncumbentsData = ExcIncumbentsData.drop(columns='SUBMISSIONID')
        ColumnOrder = Setup.iloc[0:43]['ExcIncumbentsOrder'].tolist()
        ExcIncumbentsData = ExcIncumbentsData[ColumnOrder]

    if AGCRematches_YN == 'Y':
        global AGCRematchesData
        AGCRematchesData = AGCRematchesData.merge(ContactSlice,
                                                  left_on='SOURCE_ORGDATA_SUBMISSIONID',
                                                  right_on='SUBMISSIONID')
        AGCRematchesData= AGCRematchesData.drop(columns='SUBMISSIONID')
        ColumnOrder = Setup.iloc[0:9]['AGCRematchesOrder'].tolist()
        AGCRematchesData = AGCRematchesData[ColumnOrder]

    if MultipleYTPos_YN == 'Y':
        global MultipleYTPositionsData
        MultipleYTPositionsData = MultipleYTPositionsData.merge(ContactSlice,
                                                                left_on='ORGDATA_SUBMISSIONID',
                                                                right_on='SUBMISSIONID')
        ColumnOrder = Setup.iloc[0:12]['MultipleYTPosOrder'].tolist()
        MultipleYTPositionsData = MultipleYTPositionsData[ColumnOrder]

    if MultipleYTAll_YN == 'Y':
        global MultipleYTPositionsAll 
        MultipleYTPositionsAll = MultipleYTPositionsAll.merge(ContactSlice,
                                                                 left_on='ORGDATA_SUBMISSIONID',
                                                                 right_on='SUBMISSIONID')
        ColumnOrder = Setup.iloc[0:12]['MultipleYTAllOrder'].tolist()
        MultipleYTPositionsAll = MultipleYTPositionsAll[ColumnOrder]


# when all data tabs are prepared, we can obtain necessary info for SUMMARY tab
def create_summary():
    # getting Excluded Entities stats
    global Summary
    if ExcEntities_YN == 'Y':
        ExcEntitiesSlice = ExcEntitiesData.loc[:,['CONTACT_SUBMISSIONID','EXCLUDED']]
        Summary = Summary.merge(ExcEntitiesSlice, left_on = 'SUBMISSIONID',
                                right_on = 'CONTACT_SUBMISSIONID',
                                how = 'left')
        Summary = Summary.drop(columns = 'CONTACT_SUBMISSIONID')
    else:
        Summary.loc[:,'EXCLUDED'] = 'n/a'

    # ...Excluded Incumbents...
    if ExcIncumbents_YN == 'Y':
        ExcIncumbentsSlice = ExcIncumbentsData.loc[:,['ORGDATA_SUBMISSIONID',
                                                   'ALLINCUMBENTS',
                                                   'EXCLUDED_INCUMBENTS']]
        Summary = Summary.merge(ExcIncumbentsSlice, left_on = 'SUBMISSIONID',
                                right_on = 'ORGDATA_SUBMISSIONID',
                                how = 'left')
        Summary = Summary.drop(columns = 'ORGDATA_SUBMISSIONID')
    else:
        Summary.loc[:,'ALLINCUMBENTS'] = 'n/a'
        Summary.loc[:,'EXCLUDED_INCUMBENTS'] = 'n/a'

    # ...AGCRematches...
    if AGCRematches_YN == 'Y':
        AGCSlice = AGCRematchesData.loc[:,['SOURCE_ORGDATA_SUBMISSIONID',
                                        'OBJECTID_COUNT']]
        Summary = Summary.merge(AGCSlice, left_on = 'SUBMISSIONID',
                                right_on = 'SOURCE_ORGDATA_SUBMISSIONID',
                                how = 'left')
        Summary = Summary.drop(columns = 'SOURCE_ORGDATA_SUBMISSIONID')
    else:
        Summary.loc[:,'OBJECTID_COUNT'] = 'n/a'

    # ...YTitle data...
    if MultipleYTPos_YN == 'Y':
        YTSlice = MultipleYTPositionsData.loc[:,['ORGDATA_SUBMISSIONID',
                                              'UNIQUEYOURTITLE']]
        # in Ytitles stats are by YOUR_TITLE etc, with duplicated SubIDs,
        # so we have to prepare a list of unique values
        z = YTSlice.iloc[:,0].value_counts().to_frame()
        z['SUBMISSIONID'] = z.index
        Summary = Summary.merge(z, left_on = 'SUBMISSIONID',
                                right_on = 'SUBMISSIONID',
                                how = 'left')
        Summary = Summary.rename(columns = 
                                 {'ORGDATA_SUBMISSIONID':'UNIQUEYOURTITLE'})
    else:
        Summary.loc[:,'UNIQUEYOURTITLE'] = 'n/a'

    # ...Deadlines...
    if Deadlines_YN == 'Y':
        DeadlinesSlice = AfterDeadlinesData.loc[:,['SUBMISSIONID',
                                                'DEADLINE_BREACH']]
        Summary = Summary.merge(DeadlinesSlice, left_on = 'SUBMISSIONID',
                                right_on = 'SUBMISSIONID',
                                how = 'left')
    else:
        Summary.loc[:,'DEADLINE_BREACH'] = 'n/a'

    #...QAD...
    if QAD_YN == 'Y':
        Summary = Summary.drop(columns = 'MERCER_ACTION')
        QADSlice = MDAData.loc[:,['SUBMISSIONID','DELAY','MERCER_ACTION']]
        Summary = Summary.merge(QADSlice, left_on = 'SUBMISSIONID',
                                right_on = 'SUBMISSIONID',
                                how = 'left')
    else:
        Summary.loc[:,'DELAY'] = 'n/a'
        Summary.loc[:,'MERCER_ACTION'] = 'n/a'

    # Setting correct column order and making sure their names are OK
    ColumnOrder = Setup.iloc[0:15]['SummaryOrder'].tolist()
    Summary = Summary[ColumnOrder]    

    # filling up NAN values and other rubbish with "n/a" for easy removal
    Summary.fillna(value = 'n/a', inplace = True)

    # removing records which, after applying tresholds, are not displaying any
    # issues and/or display them only on irrelevant tabs (e.g. QAD_YN = N, etc)
    y = 0
    for x in Summary.SUBMISSIONID:
        z = Summary.iloc[y,7:14].unique()
        Summary.loc[y,'removal'] = str(z)
        y = y + 1
    Summary = Summary[Summary.removal != "['n/a']"]
    Summary = Summary.drop(columns = 'removal')


#   CREATING XLSX FILE FOR FINAL REPORT
#   function responsible for opening up Template and filling it with data 
def create_report_file():

    print('opening template...')
    template = pyxl.load_workbook(filename = TemplateName)

    # Copying data (dates, names) from Settings
    print('updating template...')
    sheet = template.active
    sheet['B1'].value = '2019 {} - Problematic Companies'.format(SurveyFullName)
    sheet['D32'].value = SubmissionDeadline
    sheet['D33'].value = InternalDeadline
    sheet['D34'].value = InternalDeadline
    sheet['D35'].value = QAD

    # copying treshold values, with an addition of formatting
    sheet = template['Tresholds']
    sheet['C2'] = '>{}%'.format(int(tresholds.iloc[0,2]*100))
    sheet['C3'] = '>{}'.format(int(tresholds.iloc[1,2]))
    sheet['C4'] = '>{}%'.format(int(tresholds.iloc[2,2]*100))
    sheet['C5'] = '>{}'.format(int(tresholds.iloc[3,2]))
    sheet['C6'] = '<{}%'.format(int(tresholds.iloc[4,2]*100))
    sheet['C7'] = '>{}'.format(int(tresholds.iloc[5,2]))
    sheet['C8'] = '>{}'.format(int(tresholds.iloc[6,2]))
    sheet['C9'] = '>{}'.format(int(tresholds.iloc[7,2]))

    # saving the file in the output folder and with final name   
    print('saving template...')
    template.save('{}\\{}'.format(Output, ReportName))
    print('done!')    


#   CREATING FINAL REPORT
#   functions for getting final data for our template
#   and saving them in final Excel   
def create_final_report():

    # creating writer tool which will copy & paste data
    # while preserving original file structure
    print('preparing to copy data...')
    Report = '{}\\{}'.format(Output, ReportName)
    Writer = pd.ExcelWriter(Report, engine = 'openpyxl')
    Book = pyxl.load_workbook(Report)
    Writer.book = Book
    Writer.sheets = dict((ws.title, ws) for ws in Book.worksheets)
    
    # creating summary
    print('copying Summary data...')
    Summary.iloc[:,0:7].to_excel(Writer,
                sheet_name = 'Summary',
                header = None, index = False,
                startrow = 1)
    Summary.iloc[:,7:].to_excel(Writer,
                sheet_name = 'Summary',
                header = None, index = False,
                startrow = 1, startcol = 8)
    
    print('done!')
    

    #checking each tab for YN confirmation for tool to copy its data
    if ExcEntities_YN == 'Y':
        print('copying Excluded Entities data...')
        ExcEntitiesData.iloc[:, 0:7].to_excel(Writer,
                                sheet_name = 'Excluded Entities',
                                header = None, index = False,
                                startrow = 4)
        ExcEntitiesData.iloc[:,7:].to_excel(Writer,
                                sheet_name = 'Excluded Entities',
                                header = None, index = False,
                                startrow = 4, startcol = 8)
        print('done!')
    else:
        print('skipping Excluded entities')


    if ExcIncumbents_YN == 'Y':
        print('copying Excluded Incumbents data...')
        ExcIncumbentsData.iloc[:, 0:8].to_excel(Writer,
                             sheet_name = 'Excluded Incumbents',
                             header = None, index = False,
                             startrow = 4)
        ExcIncumbentsData.iloc[:, 8:].to_excel(Writer,
                             sheet_name = 'Excluded Incumbents',
                             header = None, index = False,
                             startrow = 4, startcol = 9)
        print('done!')
    else:
        print('skipping Excluded Incumbents')


    if AGCRematches_YN == 'Y':
        print('copying AGC Rematches data...')
        AGCRematchesData.iloc[:, 0:8].to_excel(Writer,
                            sheet_name = 'AGC Rematches',
                            header = None, index = False,
                            startrow = 4)
        AGCRematchesData.iloc[:,8:].to_excel(Writer,
                            sheet_name = 'AGC Rematches',
                            header = None, index = False,
                            startrow = 4, startcol = 9)
        print('done!')
    else:
        print('skipping AGC Rematches')


    if MultipleYTPos_YN == 'Y':        
        print('copying Multiple YT Positions data...')
        MultipleYTPositionsData.iloc[:, 0:8].to_excel(Writer,
                                   sheet_name = 'Multiple YT Positions',
                                   header = None, index = False,
                                   startrow = 4)
        MultipleYTPositionsData.iloc[:, 8:].to_excel(Writer,
                                   sheet_name = 'Multiple YT Positions',
                                   header = None, index = False,
                                   startrow = 4, startcol = 9)
        print('done!')
    else:
        print('skipping Multiple YT Positions')


    if MultipleYTAll_YN == 'Y':
        print('copying Multiple YT All Data...')
        MultipleYTPositionsAll.iloc[:, 0:8].to_excel(Writer,
                                   sheet_name = 'Multiple YT All Data',
                                   header = None, index = False,
                                   startrow = 4)
        MultipleYTPositionsAll.iloc[:, 8:].to_excel(Writer,
                                   sheet_name = 'Multiple YT All Data',
                                   header = None, index = False,
                                   startrow = 4, startcol = 9)
        print('done!')
    else:
        print('skipping Multiple YT All Data')


    if Deadlines_YN =='Y':
        print('copying After Deadlines data...')
        AfterDeadlinesData.iloc[:, 0:7].to_excel(Writer,
                                   sheet_name = 'After Deadline',
                                   header = None, index = False,
                                   startrow = 4)
        AfterDeadlinesData.iloc[:, 7:].to_excel(Writer,
                                    sheet_name = 'After Deadline',
                                    header = None, index = False,
                                    startrow = 4, startcol = 8)
        print('done!')
    else:
        print('skipping After Deadlines data')


    if QAD_YN == 'Y':
        print('copying QAD & MDA data...')
        MDAData.iloc[:, 0:7].to_excel(Writer,
                                   sheet_name = 'DVF after QAD & MDA',
                                   header = None, index = False,
                                   startrow = 4)
        MDAData.iloc[:, 7:].to_excel(Writer,
                                   sheet_name = 'DVF after QAD & MDA',
                                   header = None, index = False,
                                   startrow = 4, startcol = 8)
        print('done!')
    else:
        print('skipping QAD & MDA data')
    
    print('Saving...')  # new print added as .save() takes some time to finish
    Writer.save()
    print('Report is ready')
    

def __main__():
    import_xlsx_files(Path)
    print('transforming data...')
    make_names_standard()
    create_excluded_entities()
    create_exclude_reasons()
    create_excluded_incumbents()
    create_YTPos()
    create_YTAll()
    create_after_deadline()
    create_mda()
    create_contact_details()
    create_summary()
    print('done!')
    create_report_file()
    create_final_report()

__main__()
